import template from 'babel-template';
import generate from 'babel-generator';
import * as t from 'babel-types';
import traverse from 'babel-traverse';
import flatten from 'flatten';
import toStringLiteral from './util/toStringLiteral';

let generateConditions = (...conditions) => {
    if (conditions.length === 1) {
        return conditions[0];
    }
    return t.logicalExpression(
        '&&',
        generateConditions.apply(null, conditions.slice(0, conditions.length - 1)),
        conditions[conditions.length - 1]
    );
};

export let warning = () => {
    return  `/* !\n` +
            `   ! Please don't edit this file by hand;\n` +
            `   ! it is automatically generated by the css-values module.\n` +
            `   ! */\n\n`;
};

export let exportModules = exported => {
    const exportTemplate = template('module.exports = EXPORTS');

    let ast = exportTemplate({
        EXPORTS: t.arrayExpression(exported.map((value, index) => {
            if (index === exported.length - 1) {
                return t.identifier(`\n    ${value}\n`);
            }
            return t.identifier(`\n    ${value}`);
        }))
    });

    return generate(ast).code + '\n';
};

export let requireModule = opts => {
    const requireTemplate = template('var IDENTIFIER = require(MODULE);');

    let ast = requireTemplate({
        IDENTIFIER: t.identifier(opts.identifier),
        MODULE: t.stringLiteral(opts.module)
    });

    return generate(ast).code + '\n';
};

export let plugin = () => {
    const dependencies = [
        requireModule({
            identifier: 'validators',
            module: `./properties/`
        }),
        requireModule({
            identifier: 'valueParser',
            module: `postcss-value-parser`
        })
    ];
    const tmpl = template(`
    module.exports = function isValid (cssString) {
        var parts = cssString.split(':').map(function (value) {
            return value.trim();
        });
        var parsed = valueParser(parts[1]);
        var invalid = validators.some(validator => {
            if (!~validator.properties.indexOf(parts[0])) {
                return;
            }
            return !validator(parsed);
        });
        return !invalid;
    }
    `);
    
    let program = t.program([ tmpl() ]);
    
    return warning() + dependencies.join('') + generate(program).code;
};

export let property = opts => {
    const tmpl = template(`
    module.exports = function (parsed) {
        var valid = true;
        var count = 0;

        parsed.walk(function (node) {
            WORD
            STRING
            SEPARATOR
        });

        return count > COUNT ? false : valid;
    }
    `);
    
    const properties = template(`module.exports.properties = EXPORTS;`)({
        EXPORTS: t.arrayExpression(opts.properties.map(toStringLiteral))
    });
    
    let config = ['SEPARATOR', 'STRING', 'WORD'].reduce((list, key) => {
        list[key] = t.emptyStatement();
        return list;
    }, {});

    config.COUNT = t.numericLiteral(opts.count);

    let conditions = [];
    let dependencies = [];

    if (opts.values && opts.values.length) {
        if (opts.values.length === 1) {
            conditions.push(template(`node.value !== "${opts.values[0]}"`)().expression);
        } else {
            conditions.push(template(`!~VALUES.indexOf(node.value)`)({
                VALUES: t.arrayExpression(opts.values.map(toStringLiteral))
            }).expression);
        }
    }

    ['length', 'integer', 'percentage', 'number', 'time'].forEach(type => {
        if (!opts[type]) {
            return;
        }
        const camel = 'is' + type[0].toUpperCase() + type.slice(1, type.length);
        conditions.push(template(`!${camel}(node.value)`)().expression);
        dependencies.push(requireModule({
            identifier: camel,
            module: `../../validators/${camel}`
        }));
    });

    if (conditions.length) {
        config.WORD = template(`if (node.type === 'word') { inject; count++; }`)({
            inject: template('if (inject) { valid = false; return false; }')({
                inject: generateConditions.apply(null, conditions)
            })
        });
    }

    if (opts.string) {
        config.STRING = template(`if (node.type === 'string') { count++; }`)();
    }

    if (opts.repeat && opts.repeat.separator) {
        config.SEPARATOR = template(`if (node.type === 'div' && node.value === "${opts.repeat.separator}") { count --; }`)();
    }

    let program = t.program([ tmpl(config), properties ]);

    traverse(program, {
        noScope: true,
        EmptyStatement: function (path) {
            path.remove();
        }
    });

    return warning() + dependencies.join('') + generate(program).code;
};

export let test = opts => {
    let tests = (prop, valid) => {
        return value => {
            return t.objectExpression([
                t.objectProperty(
                    t.identifier('fixture'),
                    t.stringLiteral(`${prop}: ${value}`)
                ),
                t.objectProperty(
                    t.identifier('valid'),
                    t.identifier(valid ? 'true' : 'false')
                )
            ]);
        };
    };
    
    let out = t.arrayExpression(flatten(opts.properties.map(prop => {
        const {valid, invalid} = opts;
        return valid.map(tests(prop, true)).concat(invalid.map(tests(prop, false)));
    })));

    let program = t.program([
        template('module.exports = EXPORTS;')({EXPORTS: out}),
    ]);

    return warning() + generate(program).code;
};

export let tests = () => {
    const dependencies = [
        requireModule({
            identifier: 'ava',
            module: `ava`
        }),
        requireModule({
            identifier: 'plugin',
            module: `./plugin`
        }),
        requireModule({
            identifier: 'suites',
            module: `./tests`
        })
    ];
    const tmpl = template(`
    suites.forEach(function (suite) {
        suite.forEach(function (test) {
            ava(test.fixture, function (t) {
                t.same(plugin(test.fixture), test.valid);
            });
        });
    });
    `);
    
    let program = t.program([ tmpl() ]);
    
    return warning() + dependencies.join('') + generate(program).code;
};
